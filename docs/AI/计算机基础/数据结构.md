# 数据结构

## 第一章 绪论

### 时间复杂度

- 概念

	- 算法中基本语句重复执行的次数是问题规模n的某个函数f(n)，算法的时间度量记作：T(n) = O( f(n) )

	- 基本语句：执行次数最多、重复执行次数与算法执行时间成正比的语句

- 分类

	- 最好时间复杂度

	- 平均时间复杂度：所有可能输入实例在等概率条件下，算法的期望运行时间

	- 最坏时间复杂度：默认情况下算这个

- 计算方法

	- 找出语句频度最大的那条语句作为基本语句

	- 计算基本语句的频度得到问题规模n的某个函数法 f(n)

	- 取其数量级用符号“O”表示

	- 时间复杂度的计算忽略高阶项系数和低阶项

- 常见复杂度排序

	- O(1) < O(log2n) < O(n) < O(nlog2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)

		- 常对幂指阶

- 计算规则

	- 加法规则： O( f(n) ) + O( g(n) ) = O( max( f(n), g(n) ) )

	- 乘法规则：O( f(n) ) × O( g(n) ) = O( f(n) × g(n) )

- 经典例题

	- for(int i=0;i<n;i++){    //该语句执行n+1次，因为最后条件判断不满足还有一次
    干点啥;                     //只执行n次
}

	-  

		-  

### 空间复杂度

- 算法所需存储空间的度量：S(n) = O( f(n) )

- 算法本身要占据的空间+辅助空间（算这个，注意递归深度也是）

- 算法原地工作：算法所需的辅助空间为常量，O(1)

### 代码基础

- C

	- 指针

		-  

			-  

			-  

		- 动态内存申请

			- malloc

				-  

					- 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针

				- 如果开辟成功，则返回一个指向开辟好空间的指针
如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查
返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定（要进行强制类型转换）

				- malloc返回的指针类型要进行强制转换，否则void类型无法进行偏移

				- 申请头结点：LNode *C=(LNode*)malloc(sizeof(LNode));
在做链表题时，合并成一个新链表不需要考虑申请合并后的整个链表空间，只要申请一个头结点，再修改已有节点的指向就行

			- free

				- malloc开辟空间，用完后要用free返回空间，ptr必须与malloc开辟的一样

				-  

				- 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的
如果参数 ptr 是NULL指针，则函数什么事都不做

				-  

	- 结构体

		- 结构体类型的声明

			-  

		- 结构体变量

			-  

		- 结构体指针

			-  

			-  

			-  

				- struct是固定的语法结构
注意后面还有分号；
定义创建了一个自定义的类型

				- .的运算优先级比*高，用方式一必须加括号，推荐采用方式二结构体指针->成员名

		- 用typedef来申明方便后续定义结构体变量和指针

			-  

			-  

	- C++引用

		- 在子函数的形参前加一个&,实现在子函数内修改主函数的普通变量，如图最终可得结果11，如果不加结果为10
函数是void无返回值，所以如果不加&，变化不会同步

			- b前面加不加&可以控制a的值是否发生改变

			- &要与变量名紧密相连

			- 使用时机：在子函数中要修改主函数变量/指针变量的值时，只需要加个&，其余不需要更改

- C++

	- C++类

		-  

	-  

		-  

		- 和C的差异

			- 定义一个模板类的成员函数时，必须在函数前面加上 template<typename E>。这是因为模板允许你为不同的数据类型定义相同的行为，所以在定义具体的函数实现之前，必须先声明模板参数。

			- GTNode<E>* 这样写的目的是告诉编译器这个函数是与 GTNode<E> 类型相关联的，其中 E 是模板参数的具体类型。这样做可以保证函数能够正确地处理 GTNode 对象中的数据，因为它们都是基于相同的模板参数 E 实例化的。

			- 指针空值：C++推荐使用nullptr代替NULL，因为它更加明确地表示空指针。

			- 在用public中已经定义好的对象时，后面要打()
如21年 ： root—>element()   root—>left()

			- 输出语句：在C++中，使用std::cout和<<操作符进行输出，而不是C语言中的printf。

				- 命名空间：C++中，std::表示标准命名空间，因此在使用标准库中的函数和对象时需要加上std::前缀。

## 第二章 线性表

### 顺序表示

- 顺序存储定义：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构

	- 简言之：逻辑上相邻，物理上也相邻

- 特点

	- 以物理位置相邻表示逻辑关系，占用一片连续的存储空间

	- 优点

		- 随机访问，即通过首地址和元素序号可在时间O(1)内找到指定元素

	- 缺点

		- 插入、删除元素需要移动大量元素、浪费存储空间、数据元素个数不能自由扩充

- 定义实现

	- 静态分配

		- 类型定义

	- 动态分配

		- 类型定义

			- //定义变量
SqList L; 
//实现
L.data=(ElemType*)malloc(sizeof(ElemType)*MaxSize);       //C语言
L.data=new ElemType[MaxSize];                                            //C++

				- C语言

					- malloc(m)函数：开辟m字节长度的地址空间，并返回这段空间的首地址

					- sizeof(x)运算：计算变量x的长度

					- free(p)函数：释放指针p所指变量的存储空间

				- C++

					-  

		- 注意：动态分配不是链式存储，它同样属于顺序存储结构，物理结构没有变化，只是分配的空间大小可以在运行时动态决定

- 基本操作的实现

	- 注意：线性表元素序号从1开始（逻辑位序和物理位序相差1）

		- 合法插入位置：1 <= i <= n+1

	- 插入操作

		- 在顺序表的指定位置插入新元素，由于表中元素的物理位置是相邻的，所以当插入新元素的时候就需要对表中的元素进行整体移动

		- 插入操作的平均移动次数

			- 假设在n+1个位置上插入元素概率为：Pi=1/(n+1)

			-  

	- 删除操作

		- 删除指定位置元素，将后续元素依次向前移动一个位置

		- 删除操作的平均移动次数

			- 假设删除第i个元素概率：Pi=1/n

			-  

	- 按值查找（顺序查找）

		- 在顺序表中查找特定值元素的位置

		- 顺序查找的平均查找长度

			- 假设每个记录的查找概率相等：Pi = 1/n

			- ASL = P1 + 2P2 + ... + (n-1)Pn-1 + nPn = 1/n×(1+2+...+n)=1/n × n(n+1)/2 = (n+1)/2

		- 查找失败的比较次数：n
和所有比较后都对不上即可判定失败

### 链式表示

- 用一组物理位置任意的存储单元来存放线性表的数据元素（逻辑次序和物理次序不一定相同）

- 结构

	- 结点

		- 数据元素的存储映像，由数据域和指针域组成

			- 数据域data：存储元素数值数据

			- 指针域next：存储直接后继结点的存储位置

	- 头指针

		- 用来标识单链表，始终指向单链表第一个结点

	- 头结点

		- 单链表第一个结点前附加一个结点，头结点数据域可以不设任何信息，也可以记录表长等

			- 引入头结点后，第一个数据结点和其他数据结点的操作一致，无需特殊处理；且空表和非空表的处理得到统一

- 特点

	- 优点

		- 解决顺序表大量连续存储单元的缺点，插入和删除操作无需移动元素

	- 缺点

		- 指针域浪费空间、查找操作需要从头遍历（顺序查找方式）

- 单链表

	- 定义实现

		- 结点类型和链表指针定义

			- 定义链表L：LinkList L;
定义结点指针p：LNode *P;

	- 操作

		- 头插法建立单链表

			-  

				- 从一个空表开始，生成新结点，插入到当前链表的表头，即头结点之后

				- 注意：生成的链表中结点的次序和输入数据顺序相反，可以利用该特点进行链表转置

		- 尾插法建立单链表

			-  

				- 将新结点插入到链表的表尾，为此需增加一个尾指针

				- 产生链表结点次序和输入数据顺序一致

		- 对结点S进行前插操作

			- 新建结点X连在结点S后

				- 交换X与S中数据

		- 其他操作略（查找、插入、删除、求表长）
本质上只要学会结点链表定义，其他操作都是对指针的操作，弄清楚箭头顺序即可，原则是确保不会造成断链和结点丢失

- 双链表

	- 概念

		- 为了能快速对前驱结点操作，引入双链表。双链表结点中有两个指针prior与next，分别指向其前驱结点和后继结点

			- typedef struct DNode{
        ElemType data;
        struct DNode *prior, *next;
}DNode, *DLinklist

	- 插入操作

		-  

			- s->next=p->next;         //将结点*s插入到结点*p之后
p->next->prior=s;
s->prior=p;
p->next=s;     //第四句要在第一二句之后

				- 链表的操作原则是，确保不会造成断链和结点丢失

	- 删除操作

		-  

			- p->next=q->next;
q->next->prior=p;
free(q);

- 循环链表

	- 循环单链表

		-  

			- 概念

				- 与单链表区别：表中最后一个结点的指针不是NULL，而指向头结点，形成一个环

			- 判空条件

				- 头结点的指针是否等于头指针

			- 注意：循环单链表一般不设头指针，只设尾指针R（王道讲课似乎都是头指针）

	- 循环双链表

		-  

			- 概念

				- 与循环单链表区别：头结点的prior指针还要指向表尾结点

			- 判空条件

				- 当循环双链表为空时，头结点的prior域和next域都等于L

- 静态链表

	-  

		- 概念

			- 静态链表借助数组来描述线性表的链式存储结构，结点也有数据域和指针域，其指针是结点的相对地址（数组下标，又称游标）

		- 特点

			- 需要预先分配一块连续内存空间（容量固定不变）、插入删除无需移动元素、不能随机存取

		- 适用场景

			- 不支持指针的低级语言、数据元素数量固定不变的场景（如操作系统的文件分配表FAT）

- 不同链表的时间效率比较

		- 查找表头结点

			- 查找表尾结点

				- 查找结点*P的前驱结点

	- 带头结点的单链表L

		- L->next，时间复杂度O(1)

			- 从L->next依次向后遍历，时间复杂度O(n)

				- 通过p->next无法找到其前驱（双指针可以）

	- 带头结点仅设头指针L的循环单链表

		- L->next，时间复杂度O(1)

			- 从L->next依次向后遍历，时间复杂度O(n)

				- 通过p->next可以找到其前驱，时间复杂度O(n)

	- 带头结点仅设尾指针R的循环单链表

		- R->next，时间复杂度O(1)

			- R，时间复杂度O(1)

				- 通过p->next可以找到其前驱，时间复杂度O(n)

	- 带头结点的双向循环链表L

		- L->next，时间复杂度O(1)

			- L->prior，时间复杂度O(1)

				- p->prior，时间复杂度O(1)

### 顺序表和链表的比较

- 比较项目\存储结构

	- 顺序表

		- 链表

- （空间）存储空间

	- 预先分配，会导致空间闲置或溢出

		- 动态分配，不会出现闲置或溢出现象

- （空间）存储密度

	- 不用为表示结点间的逻辑关系而增加额外存储开销

		- 需要借助指针体现元素间逻辑关系，存储密度小于1

- （时间）存取元素

	- 随机存取，按位置访问元素时间为O(1)

		- 顺序存取，按位置访问元素复杂度为O(n)

- （时间）插入、删除

	- 平均移动约表中一半元素，时间复杂度O(n)

		- 无需移动元素，确定位置后时间复杂度为O(1)

- 适用情况

	- 表长变化不大，且能事先确定变化范围
很少进行插入删除操作，经常按元素位置访问(存取)

		- 长度变化较大
频繁进行插入或删除操作

### 单链表代码题

-  

	- 涉及位序

		- 有表头节点，int length=0

	- 前后指针

		- 删除

		- 插入

	- 头插法原地逆置

		- 只新申请了一个头结点

	- 尾插法保持原序

		-  

## 第三章 栈、队列和数组

### 栈

- 栈的概念

	-  

		- 限定仅在一端进行插入和删除操作的线性表，又称后进先出（LIFO）的线性表；
允许插入删除的那一端叫栈顶（Top），不允许插入和删除的一端叫栈底（Bottom）

			- 特殊的线性表，后进先出（LIFO）

	- 注意：n个不同元素进栈，出栈元素不同排序个数为（n个元素能构成多少种不同的二叉树）

		- 卡特兰数

			- 卡特兰数的应用：
栈的应用：在研究栈的操作过程中，卡特兰数可以用来计算出所有可能的合法的入栈和出栈序列的数量。
二叉树：卡特兰数还可以用来计算给定节点数的不同形状的二叉树的数量。
括号匹配：卡特兰数同样适用于计算包含n对括号的所有正确匹配的组合数。

	- 压栈弹栈序列的问题：进入的序列后面的反而在弹出序列前面的最有可能是错误选项
如进入序列是12345，若弹出序列5开头，只能是54321，若弹出序列4开头，则后面4321的顺序不能变，5可能在其中的任何一处空位

- 栈的实现

	- 栈的顺序存储结构

		- 顺序栈的基本结构

			-  

				- 利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时设一个栈顶指针（Top）

				- 基础结构

					- 栈顶指针，初始值：S.top = -1（若有元素，则指向栈顶元素S.data[S.top]）

					- 进栈：栈不满时，栈指针先+1，再送值到栈顶
S.data[++S.top]=x

						- 出栈：栈非空时，先取栈顶元素值，再将栈顶指针-1
x=S.data[S.top--]

					- 栈空条件：S.top == -1

						- 栈满条件：S.top == MaxSize-1

							- 栈长：S.top + 1

		- 顺序栈的基本操作

			- 初始化、判栈空、进栈、出栈、读栈顶元素（本质就是操作顺序表）

	- 栈的链式存储结构

		-  

			- 采用单链表实现，并规定所有操作都是在单链表的表头进行

			- 优点

				- 便于多个栈共享存储空间和提高效率，不存在栈满上溢的情况

- 栈的应用

	- 表达式求值

		- 中缀表达式转后缀表达式

			- 从左到右遍历各元素

				- 若遇到操作数：直接加入后缀表达式

				- 遇到界限符：“(”直接入栈；“)”则依次弹出栈内运算符并加入后缀表达式，直到弹出“(”为止

				- 遇到运算符：依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(”或栈空则停止，之后再把运算符入栈

				- 左优先

		- 中缀表达式转前缀表达式

			- 同理但从右到左遍历，“(”和“)”与中缀转后缀的功能相反，最后结果依次翻转

			-  

		- 中缀表达式的计算

			- 初始化操作数栈和运算符栈

			- 若扫描到操作数，压入操作数栈；若扫描到运算符或界限符，按“中缀转后缀”的逻辑压入运算符栈（可能弹出运算符，若弹出则将栈顶的两个操作数运算压回操作数栈）

		- 后缀表达式的计算

			- 从左向右扫描元素，若扫描到操作数则压入栈，若扫描到运算符<op>则弹出两个栈顶元素Y和X，执行运算X<op>Y，将结果压回栈中

		- 前缀表达式的计算

			- 同上，但从右向左

### 队列

- 队列的概念

	-  

		- 是一种操作受限的线性表，只允许在表的一端进行插入（队尾），另一端进行删除（队头）

			- 特殊的线性表，先进先出（FIFO）

		- 队头：删除元素的一端

			- 队尾：插入元素的一端

				- 想想排队买奶茶

- 队列的实现

	- 队列的顺序存储结构

		-  

			- 分配一块连续的存储单元存放队列元素，设两个指针

				- 队头指针front：指向队头元素
队尾指针rear：指向队尾元素的下一个元素

			- 基础结构

				- 初始状态（队空条件）：Q.front == Q.rear == 0

				- 进队操作：队不满时，先送值到队尾元素，再将队尾指针+1

				- 出队操作：队不空时，先取队头元素值，再将队头指针+1

			- 假溢出：在data数组依然存在空位置时，却已经满足队列满的条件（Q.rear==MaxSize,出栈的元素位置空闲）

				- Q.front前面的仍然空闲

		- 循环队列

			-  

				- 概念

					- 把存储队列元素的表逻辑上视为一个环

				- 基本操作

					- 初始时：Q.front = Q.rear = 0

					- 队头指针+1：Q.front = (Q.front + 1) % MaxSize

					- 队尾指针+1：Q.rear = (Q.rear + 1) % MaxSize

					- 队列长度：(Q.rear + MaxSize - Q.front) % MaxSize

					- 队空：Q.front == Q.rear

				- 队满判断

					- 牺牲一个单元来区分队空和队满，即队头指针在队尾指针的下一位置作为队满标志

						- 队满条件：(Q.rear + 1) % MaxSize == Q.front

					- 类型中增设表示元素个数的数据成员（int size）

						- 队空：Q.size == 0

						- 队满：Q.size == MaxSize

					- 类型中增设tag数据成员，以区分是队满还是队空

						- tag == 0时，若因删除导致Q.front == Q.rear，则队空

						- tag == 1时，若因插入导致Q.front == Q.rear，则队满

	- 队列的链式存储结构

		-  

			- 队列的链式表示时一个同时带有队头指针和队尾指针的单链表

			- 头指针指向队头结点，队尾指针指向队尾结点，当Q.front == NULL且Q.rear == NULL时，队列为空

			- 不存在队列满且溢出问题，适合于数据元素变动较大的情况

- 双端队列（挺喜欢考的考点）

	- 概念

		- 双端队列是指允许两端都可以进行入队和出队操作的队列，其逻辑结构仍是线性表

	- 分类

		- 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列

			- 做题方法：画图标出输入输出口，将输出序列从输出口处写上，判断能否输入得到这种序列

		- 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列

- 栈和队列有相同逻辑结构，线性结构

- 合适与不合适做链队的链表，关键看能不能获取到首尾指针（带首尾的非循环或带尾的循环）

	- 单链表实现队列，队头只能设置在链头（关注删除操作，需找到新队头）

### 多维数组存储

- 概念

	- 数组是由n个相同类型的数据元素构成的有限序列，每个元素在n个线性关系中的序号称为元素下标，下标取值范围称为数组的维界

- 与线性表的关系

	- 数组是线性表的推广，一维数组可视为一个线性表，二维数组可以视为其元素也是定长线性表的线性表

- 数组的存储结构

	- 数组的所有元素在内存中占用一段连续的存储空间

	- 一维数组

		- 存储结构关系式：LOC(ai) = LOC(a0) + i × L    （0 <= i < n，L是每个元素所占存储单元）

	- 二维数组

		- 按行优先（一行行存储）

			- 存储结构关系式：LOC(ai,j) = LOC(am,n) + [(i-m) × (h2 ) + (j-n)] × L        （二维数组：h1 × h2）

			- 存储结构关系式：LOC(ai,j) = LOC(a0,0) + [i × (h2 ) + j] × L        （二维数组：h1 × h2）

		- 按列优先（一列列存储）

			- 存储结构关系式：LOC(ai,j) = LOC(a0,0) + [j × (h1 ) + i] × L        （二维数组：h1 × h2）

	- 三维数组

		- Amxnxp：mnp，可能是行列页的顺序，也可能是页行列的顺序，在计算时需要根据答案来逆推（两个都算）

			- 按行优先时，先第一行第一列各页，再第一行第二列各页，第一行完成后再第二行

				- 行列页：存储结构关系式：LOC(ai,j,k) = LOC(a0,0,0) + [inp+jp+k]
页行列：存储结构关系式：LOC(ai,j,k) = LOC(a0,0,0) + [jmp+km+i]

					- 理解意思公式就直接写了

			- 按列优先时，先第一列第一行各页，再第一列第二行各页，第一列完成后再第二列

				- 行列页：存储结构关系式：LOC(ai,j,k) = LOC(a0,0,0) + [jmp+ip+k]
页行列：存储结构关系式：LOC(ai,j,k) = LOC(a0,0,0) + [kmn+jm+i]

### 特殊矩阵

- 指具有许多相同矩阵元素或0元素，并且这些相同矩阵元素或0元素的分布有一定规律

- 压缩矩阵

	- 找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现分布规律的、多个值相同的元素只分配一个存储空间，对0元素不分配空间

- 对称矩阵

	- 概念

		- 若对一个n阶方阵中的任意元素a(i, j) = a(j, i)，则称其为对称矩阵，可放在一维数组B[n(n+1)/2]中

	- 存储位置计算公式

		-  

- 三角矩阵

	- 概念

		- （上/下）三角区的所有元素均为同一常量，其可压缩为存储完（下/上）三角区和主对角线上元素 + 存储常量一次

	- （下/上）三角矩阵元素下标对应关系

		- 下三角矩阵

			- 上三角矩阵

	- （下/上）三角矩阵在内存中的压缩存储形式

		- 下三角矩阵

			- 上三角矩阵

				- 别忘常量！！！！！

- 三对角矩阵

	-  

		- 概念

			- 又称带状矩阵，除以对角线为中心的3条对角线区域外都为0

		- 压缩存储：将元素按行优先方式存放在一维数组B中，且a(i, j)与B[k]对应关系为：k = 2i + j - 3

		- 若问一维数组所需的存储空间，则是n+2(n-1)=3n-2,（主对角线+2条上下的）

- 稀疏矩阵

	- 概念

		- 矩阵中非0元素的个数t，相对矩阵元素的个数s来说非常少，即s>>t

	- 存储方式

		- 三元组（行标、列标、值）

			-  

				- 十字链表法

					-  

	- 稀疏矩阵压缩存储后失去了随机存取的特性

## 第五章 树与二叉树

### 树的基本概念

- 树的定义（一种逻辑结构，具有层次关系）：树是n个结点的有限集

	- 若n=0，称为空树

	- 若n>0，则需要满足如下两个条件

		- 有且仅有一个特定的称为根的结点

		- 其余结点可分为m个互不相交的有限集T1、T2...Tm，其中每一个集合又是一棵树，并称为根的子树

- 树的基本术语

	- 结点的关系

		- 结点的祖先：从根到该结点所经分支上的所有结点

		- 结点的子孙：以某结点为根的子树中的任一结点

		- 双亲和孩子：结点的子树的根称为该结点的孩子，该结点称为孩子的双亲

		- 兄弟：有相同双亲的结点

		- 堂兄弟：双亲在同一层

	- 结点的度

		- 树中一个结点的孩子个数，树中结点的最大度数称为树的度

	- 分支结点（非终端结点）

		- 度大于0的结点

	- 叶子结点（终端结点）

		- 度为0的结点

	- 结点的层次

		- 从树根开始定义，根结点为第一层

	- 结点的深度

		- 从根结点开始自顶向下逐层累加

	- 结点的高度

		- 从叶结点开始自底向上逐层累加

	- 树的高度（深度）

		- 树中结点的最大层数

	- 有序树和无序树

		- 树中结点的各子树从左到右时有次序的，则该树为有序树，反之无序树

	- 森林

		- n课互不相交的树的集合

- 树的性质

	- 树的结点数=总度数+1

		- 度代表孩子数，除根节点外都是孩子，加1就是加根节点

		-  

	- m叉树

		-  

			- 每个结点最多只能有m个孩子的树（可以是空树）

				- 允许所有结点度<m

			- 高度为h的m叉树至少有h个结点，至多有(m^h-1)/(m-1)个结点（等比数列）

			- 具有n个结点的m叉树最小高度为 ⌈logm (n(m-1)+1)⌉

				- 二叉树具有n个节点，最小高度为log2(n+1)向上取整

				- 三叉树具有n个节点，最小高度为log3(2n+1)向上取整

	- 度为m的树

		-  

			- 任意结点的度<=m

			- 至少有一个结点度=m

				- 不可以是空树

			- 一定是非空树，至少有m+1个结点

			- 度为m，具有n个节点的树的最大高度h=n-m+1

				- m个构成1层，其余的构成n-m层

			- 高度为h，度为m的树至少有h+m-1个节点

### 二叉树

- 二叉树的定义

	- 二叉树是n个结点的有限集，它或者是空集（n=0），或者由一个跟结点及两棵互不相交的分别称作这个根的左子树和右子树的二叉树组成

	- 特点

		- 二叉树是有序树，子树有左右之分，其次序不能颠倒

		- 二叉树可以是空集合，根可以有空的左子树或空的右子树

	- 二叉树的性质

		- 非空二叉树上的叶子结点数等于度为2的结点数+1      n0=n2+1

		- 非空二叉树上第k层上至多有2^k-1个结点

		- 高度为h的二叉树至多有2^h-1结点

- 特殊的二叉树

	- 满二叉树

		- 概念

			- 一颗高度为h，且含有2^h-1个结点的二叉树称为满二叉树

		- 性质

			- 从1开始编号，对于编号为i的结点

				- 双亲为⌊i/2⌋

				- 若有左孩子，则左孩子为2i

				- 若有右孩子，则右孩子为2i+1

				- 如果题目从0开始编号，只要将条件都加1按照上面的算，最后再减1即可

	- 完全二叉树

		- 概念

			- 高度为h，有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应

		- 特点

			- i<=⌊n/2⌋则结点为分支结点，否则为叶子结点

			- 按编号，一旦出现某结点i为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点

			- 度为1的节点最多只有一个，且只有左孩子

		- 性质

			- 具有n个结点的完全二叉树的深度为⌊log2n⌋+1
（别的问法：第n个节点所在的层次）

				- 证明：二叉树深度为k，结点数量：2^(k-1)<=n<2^k，不等式取对数，推出

				- 与m叉树n个节点最小高度一致 ⌈logm (n(m-1)+1)⌉
即 ⌈log2 (n+1)⌉

			- 完全二叉树依次编号1,2,...,n，则对任一结点i有

				- 如果i>1，则其双亲结点是⌊i/2⌋

				- 如果2i>n，则结点i为叶子结点，无左孩子

				- 如果2i+1>n，则结点i无右孩子

				- 结点i所在层次（深度）为⌊log2i⌋+1

		- 补充

			- 完全二叉树

- 存储结构

	- 顺序存储结构

		- 用一组地址连续的存储单元存储二叉树，为了反映二叉树结点间的逻辑关系，需要添加很多不存在的空结点

		- 浪费空间，存储右单支树时，深度为k需要2^k-1的空间

	- 链式存储结构

		- 二叉链表

			-  

			- 含有n个结点的二叉链表中，含有n+1个空链域

		- 三叉链表（带父结点）

			-  

### 二叉树的遍历

- 概念

	- 二叉树的遍历是指按某条搜索路径访问树中每个结点，每个结点均被且仅被访问一次

- 先中后指的是根节点的访问顺序，左右访问顺序固定是先左后右

	- 分支节点逐层展开法（较慢）

	- 从你的全世界路过法

		-  

- 先序遍历

	-  

		- 先访问根结点

		- 先序遍历左子树

		- 先序遍历右子树

- 中序遍历

	-  

		- 中序遍历左子树

		- 访问根结点

		- 中序遍历右子树

- 后序遍历

	-  

		- 后序遍历左子树

		- 后序遍历右子树

		- 访问根结点

		- 可用于找祖先和子孙结点间路径

- 层次遍历

	-  

		- 先将二叉树根结点入队，然后出队，访问出队结点

		- 若它有左子树，则将左子树根结点入队

		- 若它有右子树，则将右子树根结点入队

		- 然后出队，访问出队结点......如此反复，直到队列为空

- 由遍历序列构造二叉树

	- 二叉树的先序（或后序或层序）序列和中序序列可以唯一确定一颗二叉树

		- 这样构造一颗二叉树的算法题还挺多的

		- 根据前/后/层序序列找到根节点是谁，在中序序列中划分左右序列，然后将子序列对应在前/后/层序序列，继续找根节点，直到所有都完成
注意子序列在层序中对应的不一定连在一起，最早出现的就是根节点

	-  

		- 前序AB、后序BA、层序AB

			- 先序和后序正好相反的例子
（要求高度等于节点数，是一条直链）

- 用二叉树表示算术表达式，将算术表达式转变为二叉树

	- 先序遍历对应前缀表示

	- 中序遍历对应中缀表示

	- 后序遍历对应后缀表示

	-  

### 树和森林

- 树的存储结构

	- 孩子兄弟表示法

		-  

			- 概念

				- 以二叉链表为存储结构，孩子兄弟表示法使每个结点包括：结点值、指向结点第一个孩子的左指针、指向结点下一个兄弟结点的右指针

			- 优点

				- 方便地实现树转换为二叉树的操作，易于查找结点的孩子

			- 缺点

				- 找双亲麻烦（可为每个结点设parent域指向父结点）

- 树、森林与二叉树的转换

	- 树转换成二叉树

		- 左孩子右兄弟

			-  

	- 二叉树转换成树

		-  

			-  

	- 森林转换成二叉树

		-  

			- 森林中每棵树的根节点视为平级的兄弟关系

	- 二叉树转换成森林

		-  

			-  

			- 抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉

			- 还原：将孤立的二叉树还原成树

- 树和森林的遍历

	- 树

		- 先根遍历

			- 若树非空，先访问根结点，再用先根遍历规则依次遍历根结点的每一颗子树

			- 其遍历序列与这棵树相应二叉树的先序序列相同

		- 后根遍历

			- 若树非空，先用后根遍历规则依次遍历根结点的每一颗子树，再访问根结点

			- 其遍历序列与这棵树相应二叉树的中序序列相同

		- 层次遍历

	- 森林

		- 森林的序是指其二叉树遍历时根的序，对其中的单棵树而言，先序就是先根，中序就是后根

		- 先序遍历

			- 访问森林中第一棵树的根结点

			- 先序遍历第一棵树中根结点的子树森林

			- 先序遍历除去第一棵树之后剩余树构成的森林

			-  

		- 中序遍历

			- 中序遍历森林中第一棵树的根结点的子树森林

			- 访问第一棵树的根结点

			- 中序遍历除去第一棵树之后剩余树构成的森林

			-  

	- 对应关系

		- 树

			- 森林

				- 二叉树

		- 先根遍历

			- 先序遍历

				- 先序遍历

		- 后根遍历

			- 中序遍历

				- 中序遍历

### 二叉排序树 BST

- 二叉排序树的定义

	- 特性

		- 左子树结点值（若左子树非空） < 根结点值 < 右子树结点值（若右子树非空）

		- 其左右子树本树又各是一棵二叉排序树

	- 性质

		- 中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排序的递增有序序列

- 二叉排序树的查找

	- 从根结点开始，沿某分支逐层向下比较的过程，若二叉排序树非空，先将给定值与根结点关键字比较

		- 若相等则成功

		- 若小于根结点关键字，则在左子树上查找；若大于根结点关键字，则在右子树上查找（可递归实现）

- 二叉排序树的插入

	- 过程

		- 若关键字小于根结点值，插入左子树

		- 若关键字大于根结点值，插入右子树

	- 生成

		- 按关键字序列依次插入

		- 不同插入次序的序列生成不同形态的二叉排序树

- 二叉排序树的删除

	- 若被删除的结点是叶结点，直接删

	- 若结点只有一棵左子树或右子树，让子树成为该结点的父结点的子树，代替该结点

	- 若结点有左、右两棵子树

		- 以其中序前驱值替换之（值替换），然后再删除该前驱结点（前驱是左子树中最大的结点）

		- 也可以用其中序后继替换之，然后再删除后继结点（后继是右子树中最小的结点）

- 二叉排序树的查找效率分析

	-  

		- 查找成功的平均查找长度ASL = (1*1 + 2*2 + 3*4 + 4 * 1) / 8 = 2.625

		- 查找失败的平均查找长度ASL = (3*7 + 4*2) / 9 =3.22

		- 查找效率主要取决于树的高度

			- 若二叉排序树为平衡二叉树，平均执行时间为O(log2n)

			- 若二叉排序树只有左/右孩子单支树，平均查找时间为O(n)

### 平衡二叉树 AVL

- 概念

	- 特性

		- 是二叉排序树，具有二叉排序树性质

		- 左子树与右子树的高度之差的绝对值小于等于1

		- 左子树和右子树也是平衡二叉排序树

	- 平衡因子=结点左子树的高度-结点右子树的高度

		- 故平衡二叉树中，平衡因子只能是 -1、0，1

- 平衡二叉树的插入

	- 当平衡二叉树插入一个结点时

		- 首先检查其插入路径上的结点是否因此次操作导致不平衡

		- 若不止一个失衡结点时，从最小失衡子树的根结点A开始平衡，直到所有结点都满足平衡二叉树特性
从最小失衡子树A向下找较高的孙子树属于LL/RR/LR/RL哪一类

	- LL 右单旋

		-  

			- f是A,p是B,gf是A的父节点

	- RR 左单旋

		-  

			-  

	- LR 先左后右双旋转

		- 插入过程，无论插入c的左子树还是右子树，下面转换都适用

		- 转换过程：C先左旋，后右旋

			-  

	- RL 先右后左双旋转

		-  

			- C登顶
C的原左孩子变成之后左孩子的右孩子
C的原右孩子变成之后右孩子的左孩子

	- 转换规律

		- 只有右孩子才能左旋，只有左孩子才能右旋
LL右旋，RR左旋

		- LR和RL倒着看，右孩子左旋，左孩子右旋

	-  

		- 如果记不住王道四种情况，遵循以下两个原则，代入到前四个情况理解一下，可能就懂了

		- 原则一：降低高度

			- 原则二：找出三个结点，保持二叉排序树性质

- 平衡二叉树的删除

	-  

- 查找效率分析

	- 高度为h的平衡二叉树最少节点数递推公式

		-  

		- n1=1  n2=2  n3=4  n4=7  n5=12  n6=20
n2 n3 n4 ~ni所有非叶结点的平衡因子均为-1/1

	- 平均查找长度/时间复杂度/最大深度，O(log2n)

### 哈夫曼树及其应用

- 基本概念

	- 路径

		- 从树中一个结点到另一个结点之间的分支构成这两个结点间的路径

	- 结点的路径长度

		- 两结点间路径上的分支数

	- 树的路径长度

		- 从树根到每个结点的路径长度之和

	- 权

		- 将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权

	- 结点的带权路径长度

		- 从根结点到该结点之间的路径长度与该结点的权的乘积

	- 树的带权路径长度

		- 树中所有叶子结点的带权路径长度之和

- 哈夫曼树的定义

	- 最优二叉树，在含有n个带权叶节点的二叉树中，带权路径长度（WPL）最短的二叉树

		- 带权路径长度只算叶节点

- 哈夫曼树的构造

	-  

		- 每次从合成后存在的结点中选出两个权最小的进行构造二叉树，直到所有结点均在树中

		- WPL的计算：法1如图
法2直接蓝色节点的值相加

			- 法1在917考题中，如果代路径长度算出来的结果选项中没有，就代层数来算（即每个路径长度加1）

	- 哈夫曼算法的时间复杂度为O(nlog2n)

- 哈夫曼编码

	- 哈夫曼树的应用，数据压缩编码技术，是最优前缀码

	- 基本概念

		- 固定长度编码：在数据通信中，对每个字符用等长二进制位表示

		- 可变长编码：对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，起到压缩效果

		- 前缀编码：没有一个编码是另一个编码的前缀，这样的编码就是前缀编码

	- 构造哈夫曼编码

		-  

			- 将每个出现的字符当作一个独立的结点，其权值为它出现的频度（或次数），构造出对应的哈夫曼树

			- 将字符的编码解释为从根至该字符的路径上边标记的序列

			- 其中边标记为0表示“转向左孩子”，标记为1表示“转向右孩子”

		- 题目给出编码，判断是否是哈夫曼编码的方法：
1.看是否满足前缀码
2.(1无法判别的情况下)根据给出的编码画出哈夫曼树，假设左分支为0，右分支为1，画出来后检查是否满足哈夫曼树的条件：不存在度为1的节点

			- 画出哈夫曼树后，想象根节点处有水龙头，节点就是堵起来的塞子，不会漏水的才是哈夫曼树

		- 画哈夫曼树时，要注意题目给出的只是叶节点还是所有节点

			- 给出了权重，一定要进入计算

- 多叉哈夫曼树（题目考点，类比外部排序的知识点），补0结点（虚叶结点）

## 第六章 图

### 图的定义及基本术语

- 概念

	- 图G由顶点集V(vertex)和边集E(edge)组成，记G=(V, E)，其中V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合

- 基本术语

	- 关系及路径术语

		- 邻接：有边/弧相连的两个顶点之间的关系（无向图的边：(vi, vj)，有向图的边：<vi, vj>）

		- 关联（依附）：边/弧与顶点之间的关系

		- 顶点的度：与该顶点相关联的边的数目，记为TD(v)
有向图中，顶点的度等于该顶点的入度和出度之和

		- 路径：连续的边构成的顶点序列
路径长度：路径上边或弧的数目/权值之和

		- 回路（环）：第一个顶点和最后一个顶点相同的路径

		- 简单路径：顶点不重复出现的路径
简单回路（简单环）：除路径起点和终点相同外，其余顶点均不重复出现的路径

	- 图的术语

		- 无向图：每条边都是无方向的
有向图：每条边都是有方向的

		- 无向完全图：任意两个点都有一条边
有向完全图：任意两个点都有两条边

		- 简单图：不存在重复边，不存在顶点到自身的边
多重图：反之

		- 稀疏图：有很少边或弧的图（e<nlogn）
稠密图：有较多边或弧的图

		- 子图：设有两个图G=(V, E)和G'=(V', E')，若V'是V的子集，且E'是E的子集，则称G'是G的子图

		- 网：边/弧带权的图

		- 连通图（强连通图）：在无（有）向图中，若对任何两个顶点v，u都存在从v到u的路径，则G是连通图（强连通图）

			-  

			-  

	- 子图相关术语

		-  

			- 连通分量/极大连通子图：该子图是G连通子图，将G的任何不在该子图的顶点加入，子图不再连通
强连通分量/极大强连通子图：该子图是G强连通子图，将G的任何不在该子图的顶点加入，子图不再强连通

			- 极小连通子图：该子图是G的连通子图，在该子图中删除任何一条边，子图不再连通

			- 生成树：包含无向图G所有顶点的极小连通子图

			- 生成森林，对非连通图，由各个连通分量的生成树的集合

	- 总结

		- 做题时尤其注意是有向图还是无向图

### 图的存储结构

- 邻接矩阵法

	- 概念

		- 是指用一个一维数组存储图中顶点的信息，用一个二维数组存储图中边的信息（邻接关系），二维数组即邻接矩阵

		- 数组实现的顺序存储

	- 无向图

		-  

			- 无向图的邻接矩阵是对称的

			- 顶点i的度=第i行（或第i列）中1的个数

	- 有向图

		-  

			- 有向图的邻接矩阵可能是不对称的

			- 顶点的出度 = 第i行元素之和

			- 顶点的入度 = 第i列元素之和

	- 有向网

		- 注意自己到自己的权值也是无穷

			-  

	- 缺点

		- 不便于增加和删除结点、存稀疏图浪费大量空间（O(n^2)）、统计一共有多少条边浪费时间

	- 补充

		- 邻接矩阵A的A^n[i][j]等于由顶点i到j的长度为n的路径数量

- 邻接表法

	- 概念

		- 图中顶点用一个一维数组存储，元素包含指向第一个邻接点的指针，存储顶点和头指针的一维数组叫顶点表

		- 每个顶点的所有邻接点构成一个单链表

		- 顺序+链式存储

	- 结构

		- 做题画邻接表的时候，第一列是顶点表，是数组存储，不要把它们和后面的边表画的一样，可以只画半个框放指针

			- 若为无向图，则需要存储两倍的边，存储空间为O(|V|+2|E|)

			- 若为有向图，存储空间为O(|V|+|E|)，若采用邻接表法则找出度易，找入度难；若采用逆邻接表则找入度易，找出度难

			- 有向图邻接表法中，顶点vi出度为第i个单链表中结点个数；入度为整个单链表中邻接点域值是i-1的结点个数

			- 图的邻接表表示不唯一

	- 实现

		-  

			-  

				- 顶点表结点：顶点域+边表头指针

				- 边表结点：邻接点域+指针域+权值（若为网）

	- 缺点

		- 若不构建逆邻接表则找入度麻烦、不方便检查任意一对顶点之间是否存在边

	- 对比

		-  

-  

- 综合对比

	- 常考前两个，后两个过于复杂，一般不会考代码题

- 基本操作

	-  

### 图的遍历

- 广度优先搜索BFS

	- 概念

		- 类似于二叉树的层序遍历算法，多了标记数组，用于确定已访问的结点

	- 算法思想

		-  

			- 首先访问起始顶点v（进队列），由v出发，依次访问v的各个未访问过的邻接顶点w1,w2,...,wi（都加入队列，起始顶点pop掉）

			- 然后依次访问w1,w2,...,wi的所有未访问过的邻接顶点（加入队列，并pop访问过的顶点）

			- 再从这些顶点出发，访问所有未被访问过的邻接顶点，直到遍历完成（利用队列实现）

	- 性能分析

		- 时间复杂度

			- 访问节点的时间+访问边的时间

			- 邻接矩阵存储方式：O(|V|^2)

			- 邻接表存储方式：O(|V|+|E|)

		- 空间复杂度

			- BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，O(|V|)

	- 基于邻接矩阵的遍历BFS序列是唯一的，基于邻接表的遍历所得到的BFS序列是不唯一的

		- 因为同一个图，用邻接矩阵存储是唯一的，但用邻接表不唯一

- 深度优先搜索DFS

	- 概念

		- 类似于树的先序遍历，搜索策略是尽可能深地搜索一个图

	- 算法思想

		-  

			- 首先访问图中某个起始顶点v，由v出发，访问与v邻接且未被访问的任一顶点w1，再访问与w1邻接且未访问的任一顶点，重复

			- 当不能继续向下访问，则依次退回到最近被访问的顶点，若还有邻接顶点未被访问，则从该点继续DFS，直到所有顶点均被访问为止（用递归实现）

	- 性能分析

		- 时间复杂度

			- 邻接矩阵存储方式：O(|V|^2)

			- 邻接表存储方式：O(|V|+|E|)

		- 空间复杂度

			- DFS是一个递归算法，需要工作栈辅助，最多需要图中所有顶点进栈，O(|V|)

	- 基于邻接矩阵的遍历DFS序列是唯一的，基于邻接表的遍历所得到的DFS序列是不唯一的

	- 输出语句移到退出递归前，实现逆拓扑序列输出

	- 调用函数次数

		-  

		-  

### 图的应用

- 最小生成树

	- 概念

		- 生成树：所有顶点均由边连接在一起，但不存在回路的图

		- 最小生成树：权值之和最小的那棵生成树

	- 性质

		- 最小生成树不是唯一的

			- 存在权值相同的边时可能不唯一，权值互不相等时最小生成树唯一

		- 其对应的边的权值之和总是唯一的，且是最小的

		- 最小生成树的边数=顶点数-1

	- 算法

		- 算法基于MST性质

			- 性质解释：n个顶点分属已经在生成树上的顶点集U和未在生成树上的顶点集V-U，接下来应在连通U和V-U的边中选取权值最小的边

		- Prim算法

			- 概述

				- 每次将代价最小的新顶点加入生成树

			- 实现（加顶点）

				- 开始时从图中任取一个顶点加入树T

					- Prim算法得到的最小生成树与开始节点的选择有关

				- 之后选择一个不在T中，但与当前T中顶点集合距离最近的顶点，将该点和对应边加入T，每次操作后T中顶点数和边数都+1

				- 以此类推，当所有点加入T，必然有n-1条边，即T就是最小生成树

			- 时间复杂度O（|V|^2）

				-  

		- Kruskal算法

			- 概述

				- 每次选一条权值最小的边（边按权值排序），使其连通（用并查集判断并实现）

			- 实现（加边）

				- 开始时为只有n个顶点而无边的非连通图T={V,{}}，每个顶点自成一个连通分量

				- 然后按照边的权值由小到大，不断选取当前未被选取过且权值最小的边

				- 若该边依附的顶点在两个不同的连通分量上（即加入后不构成回路），则将边加入T，否则继续选取下一条边

				- 以此类推，直到T中所有顶点都在一个连通分量上

			- 时间复杂度

				- O(|E|log|E|)，E为边数

		- 比较

			- 算法名

				- Prim算法

					- Kruskal算法

						- 任一算法能得到的最小生成树，另外一个也能得到

			- 算法思想

				- 选择点

					- 选择边

			- 时间复杂度

				- O(|V|^2)，V为顶点数

					- O(|E|log|E|)，E为边数

			- 适应范围

				- 稠密图

					- 稀疏图

- 最短路径

	- 在有向网中A点（源点）到达B点（终点）的多条路径中，找到一条各边权值之和最小的路径

	- BFS求解单源最短路径（不带权图）

		- 从2开始

			-  

	- Dijkstra算法（两点间最短路径）

		- 概述

			- 维护一个最短路径数组，每次选取最短的顶点加入，更新加入后的最短路径，直到所有顶点都访问

			- s[]记录是否访问，dist[]记录源地到各点最短路径，path[]记录前驱结点

		- 过程

			- 初始化：集合S初始为{0}（源点V0入集合），dist[]初始值dist[i]=arcs[0][i]（与源点距离）

			- 从顶点集合V-S中选出dist[]数组值最小的，即选最近的点加入

				-  

					-  

			- 修改V0出发到集合V-S上任一顶点最短路径长度：若dist[j]+arcs[j][k]<dist[k]，则更新dist[k]=dist[j]+arcs[j][k]

				-  

			- 重复步骤2-3，n-1次，直到所有顶点都包含在S中

		- 时间复杂度

			- O(|V|^2)

				- 和prim算法相同

		- 注意

			- 适合稠密图，无负权值

	- Floyd算法（任意一对顶点之间最短路径）

		- 概述

			- 维护一个各顶点间最短路径二维数组，不断试探加入中间结点，是否缩短距离（三重循环）

		- 过程

			- 初始化：对任意两个顶点vi和vj，若存在边，则二维数组上最短路径为权值（不存在则最短路径为无穷）

			- 逐步尝试在原路径上加入顶点k(k = 0,1,...,n-1)为中间结点

				-  

			- 若更新后得到路径比原本路径长度短，则新路径代替原本路径

		- 时间复杂度

			- O(|V|^3)

		- 注意

			- 允许图中有带负权值的边，但不允许有包含带负权值的边组成回路

			- 适用于带权无向图

	- 综合对比

		-  

	- 建议理解意思后，直接看下面补充代码更清晰

- 以下为有向无环图的应用

	- 有向无环图：无环的有向图，简称DAG图

	- 用一个有向图表示一个工程的各子工程及其互相制约关系

		- AOV网：顶点表示活动，弧表示活动之间的优先制约关系

		- AOE网：弧表示活动，以顶点表示活动的开始或结束事件

- 有向无环图描述表达式

	-  

	-  

		-  

	-  

		-  

- 拓扑排序（AOV网）

	- 概述

		- 拓扑序列

			- 拓扑序列是对图中所有的顶点，如果存在一条从顶点A到顶点B的路径，那么在排序中顶点A出现在顶点B的前面

		- 拓扑排序

			- 对一个有向图构造拓扑序列的过程

				- 找到做事的先后顺序

	- 过程

		- 从AOV网中选择一个没有前驱的顶点并输出

		- 从网中删除该顶点和所有以它为起点的有向边

		- 重复前两个步骤，直到当前的AOV网为空或当前网中不存在无前驱的顶点为止（后者说明有向图中存在环，有环则不存在拓扑序列）

	- 时间复杂度

		-  

		- 邻接矩阵存储，O(|V|^2)

		- 邻接表存储，O(|V|+|E|)

	- 注意

		- 若一个顶点有多个直接后继，则拓扑排序通常不唯一（若每个顶点有唯一前驱后继，则唯一）

		- 若图的邻接矩阵是三角矩阵，则存在拓扑排序，反之不一定成立

- 逆拓扑排序（AOV网）

	- DFS实现过程

		- DFS算法

			-  

	- 逆拓扑排序过程

		- 从AOV网中选择一个没有后继的顶点并输出

		- 从网中删除该顶点和所有以它为终点的有向边

		- 重复前两个步骤，直到当前的AOV网为空

- 关键路径（AOE网）

	- 概述

		- 关键路径

			- 从源点到汇点的所有路径中，具有最大路径长度的路径

		- 关键活动

			- 关键路径上的活动

	- 过程

		-  

			- 圆点代表事件，线代表活动，以下为求关键路径的步骤

			- 步骤1：求所有事件的最早发生时间ve()

				-            V1  V2  V3  V4  V5  V6
ve(k)    0     3     2     6     6     8

					- 取Max

			- 步骤2：求所有事件的最迟发生时间vl()

				- vl(k)    0     4     2     6     7     8

					- 取min

			- 步骤3：求所有活动的最早发生时间e()

				-          a1  a2   a3   a4   a5   a6   a7   a8
e(i)    0     0     3     3     2     2     6     6

					- 边起点的最早时间

			- 步骤4：求所有活动的最迟发生时间l()

				- l(i)    1     0     4     4     2     5     6     7

					- 边终点的最迟时间-耗时

			- 步骤5：求所有活动的时间余量d()

				- d(i)    1     0     1     1     0     3     0     1

					-  

			- 步骤6：关键活动（d()=0的活动就是关键活动）：a2、a5、a7
关键路径：V1--->V3--->V4--->V6

				- 执行步骤1,2其实已经能够得到结果了，ve=vl的节点就是关键路径上的节点

	- 注意

		- 关键路径上的所有活动都是关键活动，是决定整个工程的关键因素，因此可通过加快关键活动来缩短整个工程的工期

		- 不能任意缩短关键活动，因为一旦缩短到一定程度，该关键活动可能变成非关键活动

		- 网中的关键路径不唯一，只有加快那些包含在所有关键路径上的关键活动才能达到缩短工期的目的

		- 若关键活动耗时增加，则整个工程的工期增长

- 选择题概念辨析

	- 有向无环图的拓扑序列唯一，该图不一定唯一

		- 6.4.21

## 第七章 查找

### 平均查找长度ASL

-  

	- n：记录个数；pi：查找第i个记录的概率（通常为1/n）；ci：找到第i个记录所需的比较次数

### 线性表的查找

- 顺序查找（线性查找）

	- 概念

		- 顺序查找顺序表或线性链表表示的静态查找表

			- 表内元素无序

	- 过程

		- 从线性表的一端开始，逐个检查关键字是否满足条件

		- 若满足则查找成功，返回元素位置

			- 若已经查到表的另一端，且还没有找到符合条件的元素，则返回查找失败的信息

	- 优化

		- 哨兵

			- 将待查关键字存入表头，从后向前比较，可免去查找过程中每步都要检查是否查找完毕，效率可提高一倍

		- 按查找频率高低存储

			- 若无法测定，按概率动态调整记录顺序（访问频度域）

	- 平均查找长度

		- 成功（Pi=1/n）

			-  

		- 失败（Pi=1/n）

			-  下标要加n+1次

			- 查找失败的比较次数：n

- 折半查找（二分/对分查找）

	- 概念

		- 每次将待查记录所在区间缩小一半

			- 有序的顺序表

	-  

		- 在[low, high]之间找目标关键字，将给定key值与表中中间位置mid比较，若相等则查找成功

		- 不等，则根据mid所指元素与key值大小比较，调整low或high，缩小边界范围，不断重复

		- 若low>high，则查找失败

	- 判定树

		-  

			- 圆形结点为记录，值为关键字；矩形结点表示查找不成功的情况

			- 特性

				- 判定树是平衡的二叉排序树（只有最下面一层不满），且取整方向应该相同（见P284 23）

					- mid向下取整

				- 若查找表有n个关键字，则失败结点有n+1个（成功节点的空链域个数）

				- 树高h = ⌈log2(n+1)⌉（不包含失败结点）

					- 完全二叉树的计算方法

			- 查找成功平均长度

				-  

				- ASL <= h

				- 一个成功节点的查找长度等于其自身所在的层数，一个失败节点的查找长度等于其父节点所在的层数

			- 时间复杂度：O(log2n)

				- 折半查找的速度不一定比顺序查找更快

	- 仅适合于顺序存储结构，不适合于链式存储结构，且关键字有序

- 分块查找（索引顺序查找）

	- 概念

		- 吸取了顺序查找和折半查找的优点，既有动态结构（若为动态查找表，优先使用链式存储），又适用于快速查找

	- 过程

		-  

			- 将查找表分为若干子块，块内的元素可以无序，但块间有序，一个块的最大关键字小于下一个块中所有记录的关键字

			- 再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中第一个元素的地址，索引表按关键字排序

			- 查找过程：在索引表中确定记录所在块，在块内顺序查找

				- 索引表查找可以顺序，也可以折半查找

					- 折半过程

						- 若索引表中不含目标关键字，最后必停在low>high时，要在low中继续进行块内查找

	- 查找成功长度

		- 将长度为n的查找表均匀地分为b块，每块有s个记录

			- ASL = Lb（对索引表查找的ASL） + Ls（对块内查找的ASL）

				-  

		- 若块内和索引表都用顺序查找，则按顺序查找公式

			- ASL = Lb + Ls = (b+1)/2 + (s+1)/2

				- 可根据b和s的关系化简，若用折半查找，则用折半的公式替换h = ⌈log2(n+1)⌉

- 比较

		- 顺序查找

			- 折半查找

				- 分块查找

	- ASL

		- 最大

			- 最小

				- 中间

	- 表结构

		- 有序/无序表

			- 有序表

				- 分块有序

	- 存储结构

		- 顺序/线性链表

			- 顺序表

				- 顺序/线性链表

### 散列表的查找

- 散列表概述

	- 基本思想

		- 记录的存储位置与关键字之间存在对应关系

			- 对应关系------hash函数（散列函数）

	- 概念

		- 散列方法

			- 选取某个函数，依该函数按关键字计算元素的存储位置，并按此存放

			- 查找时，由同一个函数对给定值k计算地址，将k与地址单元中元素关键码进行比较，确定查找是否成功

		- 散列函数

			- 把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key) = Addr(这里的地址可以是数组下标，索引或内存地址等)

		- 散列表

			- 根据关键字而直接进行访问的数据结构，散列表建立了关键字和存储地址之间的一种直接映射关系

		- 冲突

			- 不同的关键码映射到同一个散列地址 key1 != key2，但H(key1) = H(key2)

		- 同义词

			- 具有相同函数值的多个关键字

	- 性能

		- 查找效率高，可达到 O(1) 、空间效率低

	- 使用散列表要解决好两个问题

		- 构造好散列函数

			- 所选函数尽可能简单，提高转换速度

			- 所选函数对关键码计算出的地址，应在散列地址集中致均匀分布，以减少空间浪费

		- 制定一个好的解决冲突的方案

- 散列函数的构造方法

	- 考虑的因素

		- 执行速度（即计算散列函数所需时间）、关键字的长度、散列表的大小、关键字的分布情况、查找频率

			-  

	- 要求

		- n个数据仅占用n个地址，虽然散列查找是以空间换时间，但希望散列的地址空间尽量少

		- 无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突

	- 散列函数

		- 直接定址法

			- 概述

				- 直接取关键字的某个线性函数值为散列函数

			- 散列函数

				- H(key) = key 或 H(key) = a*key + b，a和b为常数

			- 特点

				- 计算最简单，不会产生冲突

					- 适合关键字分布连续的情况（若不连续，则存储空间浪费很多）

		- 除留余数法

			- 概述

				- 假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换为散列地址

					-  

			- 散列函数

				- H(key) = key % p

			- 特点

				- 关键在p的选取，使得每个关键字通过该函数转换后等概率映射到散列空间的任一地址，减少冲突

		- 数字分析法

			- 概述

				- 设关键字是r进制数，而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀，某种数码出现机会均等。选取数码分布较为均匀的若干位作为散列地址

			- 特点

				- 适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数

		- 平方取中法

			- 概述

				- 取关键字的平方值的中间几位作为散列地址

			- 特点

				- 适合于关键字的每位取值都不够均匀或均小于散列地址所需位数

- 冲突解决的方法

	- 开放定址法

		- 概念

			- 指可存放新表项的空闲地址，即向它的同义词开发，又向其非同义词开发（删除元素时，用标记表示）

		- 数学递推公式

			- Hi = (H(key) + di) % m

				- di即为增量序列

			- 增量d的取值

				- 线性探测法

					- di = 0, 1, 2, ... , m-1

						- 发生冲突时，顺序表查看表中下一个元素，直到有空闲单元

					- 会出现聚集现象，降低查询效率，探测覆盖率高，能覆盖所有单元

						- 聚集（堆积）现象直接影响平均查找长度

				- 平方探测法

					- di = 0² , +1² ,  -1² , +2² , -2² , ... , +k² , -k² 

					- 不会出现聚集现象，不能探测所有单元，但至少能探测一半

				- 双散列法

					- 公式变为：Hi = (H(key) + i×Hash2(key)) % m

						- di=Hash2(key)，i为冲突次数，作为公式中再散列系数，别漏了

						-  

							- 不固定

				- 伪随机序列法

					- di = 伪随机数序列

		- 该方法散列表删除时注意

			-  

	- 拉链法

		- 概述

			-  

				- 为了避免冲突，把所有的同义词存储在一个线性链表（由散列地址唯一标识）中

		- 优点

			- 非同义词不会冲突，无“聚集”现象

			- 链表上结点空间动态申请，更适合于表长不确定的情况（经常插入删除）

- 散列的查找及性能分析

	- 查找过程

		- 检测由散列函数形成的地址上是否有记录，若无记录则失败；
若有记录比较关键字值，若相等则查找成功，否则散列函数更新增量值，重复执行

		- 补充：求查找失败的ASL时

			- 失败位置也计数；若H(key) = k%7，则失败要算0,1,2,3,4,5,6

		- 求ASL

			- 查找成功的

				- ASL=各元素从直接散列地址到存储地址需要比较的次数之和/元素个数

					- 直接散列地址：根据散列函数计算后直接得到的地址，无冲突处理

			- 查找失败的

				- ASL=从直接散列地址出发到存储空位需要比较的次数之和/直接散列地址的个数

	- 散列表查找效率取决于三个因素

		- 散列函数

		- 处理冲突的方法

		- 装填因子

			- 装填因子为描述一个表装满程度，越大越容易冲突

				- 冲突不可以避免

			- 装填因子α = 表中记录数n/散列表长度m

			-  

				- 平均查找长度依赖于散列表的装填因子，与表长或表项个数无直接关系

				- 影响平均查找长度的有：装填因子，散列函数，冲突解决策略，堆积现象

	- 补充

		- 散列表技术具有很好的平均性能，优于一些传统的技术

		- 链地址法优于开放定址法

		- 除留余数法作散列函数优于其它类型函数

### 做题方法整理

- 比较序列/查找路径题

	- P284-21折半查找的关键字比较序列
P307-25二叉排序树的查找路径

		- 以选项最末尾元素为方向，如果第一个>末尾元素，则第一个>后续所有元素。继续看下一个元素，如果<末尾元素，则该元素<后续所有元素

### 红色边框为一级知识点：重点

### b站：分享笔记的好人

重点考点：
1. 线性表的查找（顺序、折半、分块（概念性质平均查找长度计算））
2. 二叉排序树、平衡二叉树、红黑树（22年新考点，考前看看）
3. B树、B+树（特点、性质、B树操作、比较）
4. 散列查找（散列函数、处理冲突方法、装填因子）

## 第八章 排序

### 概述

- 排序

	- 将无序序列排成一个有序序列的运算（如果排序的数据结点包含多个数据域，排序针对一个域）

- 算法的稳定性

	- 能够使任何数值相等的元素，排序以后相对次序不变

		- 稳定性与算法优劣无关

	- 稳定性只对结构类型数据排序（如基数排序）有意义，例：先按数学成绩排序，再按总分排序

- 根据数据是否在内存中进行分类

	- 内部排序

		- 在排序期间元素全部存放在内存中的排序

	- 外部排序

		- 在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序

- 任意n个关键字基于比较的排序，至少要进行⌈log2(n!)⌉次关键字比较

	- n!表示n个关键字排列组合总可能，t次比较能产生2的t次方种可能，2^t>=n!

### 插入排序

- 直接插入排序

	- 概念

		- 首先以一个元素为有序的序列，然后讲后面的元素依次插入到有序的序列中适合的位置直到所有元素都插入有序序列

			- 每趟排序可能没有元素被放到最终位置

	- 实现过程

		- 比较的同时就移动

			- 排序某时刻将待排序表分割为三部分，顺序查出L(i)在L[1...i-1]的插入位置k

			- 将L[k...i-1]中的所有元素依次后移一个位置，将L(i)复制到L(k)

			-  

		- 哨兵

			-  

				-  

	- 性能分析

		- 时间复杂度（平均）：O(n^2)

			- 最好（有序）：O(n)

			- 最坏（逆序）：O(n^2)

		- 空间复杂度：O(1)

	- 稳定性

		- 稳定

	- 补充提高速度

		- 减少元素比较次数，引入折半插入排序

		- 减少元素的移动次数，引入希尔排序，每次移动步幅增大

	- n趟排序后，n+1个数据有序

- 折半插入排序

	- 实现过程

		- 首先确定折半插入排序的范围，利用折半查找找到插入的位置，然后一次性对数据进行移动，最后插入该元素。先比较后移动

		- 带哨兵的

			-  

			-  

				-  

	- 性能分析

		- 时间复杂度：比较次数减少为O(nlog2n)，移动次数不变仍为O（n^2），整体O(n^2)

		- 空间复杂度：O(1)

	- 稳定性

		- 稳定

	- 基于顺序存储

		- 若是链式存储则不行，虽然移动元素只需要修改链表指针，但关键字对比变复杂了

- 希尔排序

	- 概念

		- 本质上还是插入排序，只是把待排序列分成几个子序列，分别对子序列进行直接插入排序，使得序列基本有序

	- 实现过程

		- 先取一个小于n的步长d，把表中数据分为d组，所有距离为d的倍数记录在同一组，组内进行直接插入排序

			- 不是每个子表中只有两个元素，序列中所有间隔为d的元素构成一个子表，对该子表进行直接插入排序

		- 缩小步长d，不断重复直到d=1为止

			-  

		- 若d=5，两数之间有4个数

			-  

	- 性能分析

		- 时间复杂度（平均）：O(n^1.3)

			- 最坏：O(n^2)

				- 最开始就让d=1，则所有元素构成一个子表进行直接插入排序，退化为直接插入排序

			-  

		- 空间复杂度：O(1)

	- 稳定性

		- 不稳定

	- 不适用于链式存储

### 交换排序

- 概述

	- 根据序列中两个元素关键字的比较结果来对换这两个记录在序列中的位置

- 冒泡排序

	- 实现过程

		- 从前往后（从后往前）两两比较相邻元素的值，若逆序则交换，直到序列比较完

		- 每一趟会将最大的元素交换到待排序列最后一个位置（将较小的元素交换到待排序列第一个位置）

		- 进行下一趟排序，前一趟确定元素不参与

		- 如果某一趟排序过程中未发生交换，则已经整体有序，可以提前结束

			- 从后往前，都满足前<后，即已经整体有序

		-  

	- 性能分析

		- 时间复杂度（平均）：O(n^2)

			- 最好：O(n)
已经有序，进行一趟排序，过程中无交换，则已经达到整体有序，不需要再进行排序

			- 最坏：O(n^2)
逆序

		- 空间复杂度：O(1)

	- 稳定性

		- 稳定

	- 补充

		- 冒泡排序产生的有序子序列一定全局有序，即每趟会将一个元素放到最终的位置上

		- 移动次数=3*交换次数

			-  

		- 也适用于链式存储

- 快速排序

	- 实现过程

		- 枢轴元素pivot和low/high元素进行比较，然后low和high中的元素进行交换（其中一个变为空）

		- 首先选取一个元素作为枢轴，以枢轴为界将排序表分为两个部分，左边小于枢轴，右边大于枢轴

			- low空出来，查看high的值，不小于49，high--，27小于49，将27移动到low处，此时high空出来，查看low的值，此时low不大于49，low++，按此方法不断进行，直到low=high时，将枢纽元素49放到low里面

		- 然后对着两部分分别递归重复上述步骤，直到每个部分内只有一个元素或空为止

			- 采用递归实现
注意子队列的枢轴也是以第一个元素

	- 性能分析

		- 时间复杂度

			- 快速排序的运行时间与划分是否对称有关，应尽量选取可以将数据中分的枢轴元素（想象一颗二叉树）

			- 最好情况：待排序列越无序，算法效率越高：O(nlog2n)

			- 最坏情况：待排序列越有序，算法效率越低：O(n^2)

			- 平均情况：快速排序平均情况下与最优情况下运行时间很接近，是所有内部排序算法中平均时间最优的排序算法

		- 空间复杂度（平均）：O(log2n)
与最好的接近

			- 最好：O(log2n)

			- 最坏：O(n)

		-  

			- 处理每一层的元素时，对尚未确定最终位置的元素进行一次比较，时间复杂度不超过O（n）
最大n层，最小log2n层，以此确定时间复杂度

	- 稳定性

		- 不稳定

			-  

				-  

	- 优化：划分均匀

		- 选头中尾三个位置的元素比较，取中间值为枢轴元素

		- 随机选一个元素作为枢轴元素

	- 题型：判断一个序列是否是快速排序第二趟的结果

		- 划分为两种情况讨论

		- 情况1：第一趟基准元素在首端/尾端，剩下n-1个元素整体进行第二趟，再确定一个元素的最终位置。所以第二趟结束后若有首端/尾端元素确定最终位置，则至少两个元素确定最终位置。

		- 情况2：第一趟基准元素不在首端/尾端，划分开的两个子序列分别进行第二趟，再确定两个元素的最终位置。所以第二趟结束后若无首端/尾端元素确定最终位置，则至少有三个元素确定最终位置。

### 选择排序

- 概述

	- 每一趟（如第i躺）在后面n-i+1（i=1,2,...,n-1）个待排序元素中选取关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟完成

	- 选择排序的时间性能不随记录序列中关键字的分布而改变

- 简单选择排序

	- 实现过程

		- 假设排序表为L[1.....n]，第i躺排序，即从L[i.....n]中选择关键字最小的元素与L(i)交换

		- i每次增加，每趟排序可以确定一个元素的最终位置

	- 性能分析

		- 时间复杂度：O(n^2)

			-  

		- 空间复杂度：O(1)

	- 稳定性

		- 不稳定

			-  

- 堆排序

	- 基本概念

		- 堆

			- 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于（或不小于）其左右孩子结点的值

				-  

		- 大根堆

			- 每个结点的值都不小于它的左右孩子结点的值,根>=左右

		- 小根堆

			- 每个结点的值都不大于它的左右孩子结点的值，根<=左右

	- 实现过程

		- 第一步：建大（小）根堆：O(n)

			- 从后向前调整所有非终端结点[0, ⌊n/2⌋]，使其满足堆的性质

				- 每调整一个节点都要判断：
大根堆：小元素是否下坠到不能再下坠
小根堆：大元素是否下坠到不能再下坠

			- 检查是否根大于（小于）等于左右孩子，小（大）元素不断下坠（下坠过程需不断检查与左右孩子的大小）

		- 第二步：调整大（小）根堆：O(nlog2n)

			- 交换：将最大（小）根结点（堆顶元素）与最后一个结点互换

			- 元素下坠：按建堆过程调整结点

				-  

					- 大元素下坠的过程1

						- 过程2

							- 过程3

		- 完整逻辑

			- 大根堆：建堆后最大元素为根，将它交换到堆底尚未确定位置的地方，堆底元素被交换到根节点处，进行元素下坠确定新的大根堆，循环往复直到所有位置都确定。

	- 性能分析

		- 时间复杂度：O(nlog2n)

			- 建堆的时间复杂度O(n)

			- 调整堆的时间复杂度O(nlog2n)

		- 空间复杂度：O(1)

	- 稳定性

		- 不稳定

			- 建堆时2（带下线）为根，被交换到最后的位置

	-  

	- 堆中元素的插入和删除

		- 下坠对比时，若有左右子树，则两次，只有左子树，则一次

### 二路归并排序

- 实现过程

	- 假定待排序表有n个记录，可以看成n个有序子表，每个子表长度1，两两归并，得到⌈n/2⌉个长度为2或1的有序表，再两两归并，直到合并为长度n的有序表

	-  

		- 代码实现

			- 采用递归
Merge函数中，跳出第二个循环的条件肯定是有一个部分归并完了，所以后面的两个while就是将另一个没有归并完的直接归并到其中，不需要再进行比较

		- 性能分析

			- 时间复杂度：O(nlog2n)

				- 可以看成一个倒过来的二叉树，每趟都要将各个元素重新加入新序列，因此每趟的时间复杂度尾O（n）

			- 空间复杂度：O(n)

				- 递归工作栈需要O（log2n）,辅助数组需要O（n）,所以是O（n）

		- 稳定性

			- 稳定

				- 两个元素一样时优先左边的

		- 特点

			- 比较次数与初始状态无关

			- 只有归并排序O(nlog2n)且稳定

			- 比较次数：
将两个各有M,N个元素的有序表合并成一个有序表，最少比较min{m,n}次，即一个完全合并完，另一个才全部加入；最多比较M+N-1次，即两个都在最后才合并完,a1<b1<a2<b2<a3<b3<…<an<bn,相邻元素依次比较

### 基数排序

- 基本概念

	- 最高位优先（MSD）法：按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列

	- 最低位优先（LSD）法：按关键字位权重递增依次进行排序，最后形成一个有序序列

- 实现过程

	- 采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序，直到所有关键字均已排序完毕

	- 低位优先法

		-  

- 性能分析

	- 时间复杂度

		- 基数排序需要进行k躺分配和收集，一趟分配需要O(n)，一趟收集需要O(m)，所以时间复杂度为O(k(n+m))
n是元素个数，m是元素各个位所能取值的范围，k是各个元素的位数，如上代码中n=11,m=10,k=3
收集时只需要修改一个位的链表的尾指针指向下一个的，所以收集所需时间和位的范围m相关

	- 空间复杂度

		- 链式存储（王道）：O(m)，一趟需要辅助存储空间m（m个桶的头尾指针）

		- 顺序存储：O(n+m)，桶+临时存放数组

- 稳定性

	- 稳定

- 应用

	- 关键字便于分k组，即k较小时

	- 每组关键字取值范围不大，即m较少时

	- 元素个数n较大时

	-  

- 补充

	- 对数字排序时，仅能使用最低位优先法，若高位优先，最后排低位时会打乱顺序

### 排序算法的分析

- 快速排序的空间复杂度为O（log2n）
直接选择排序是简单选择排序
希尔排序最好时间复杂度只能到O(n^1.3)

	- 王道书中基数排序，d为待排元素的维度，r为基数的个数，空间复杂度王道采用链式存储，故额外空间仅每个桶的头尾指针

	- 待排序元素较少时，可采用直接插入排序而非快速排序

	- 记忆方法：（自编）（稳定性，空间复杂度，平均时间复杂度）
插冒归基你太稳，快归基空不为一。
插冒简时为n方，快归堆时为n洛。
题目中问时间复杂度时看好问什么，最好，最坏，还是平均。口诀为平均！问最好/最坏自己分析。
口诀中不包含基数排序的时间复杂度

		- 最好：对直接插入排序，冒泡排序，即为初始序列有序/基本有序；对快速排序，即为随机分布

		- 最坏：对直接插入排序，冒泡排序，即为初始序列逆序；对快速排序，即为有序/基本有序

- 结论

	- 选择一个排序算法时，要考虑数据的规模、数据的存储方式、算法的稳定性、数据的初始状态来结合算法的时空效率进行综合考察

	- 若n较小，采用直接插入排序或简单选择排序

	- 若n较大，采用时间复杂度尾O（nlog2n）的排序算法：快归堆

		- 可以用一棵二叉树来描述判定过程的至少需要O（nlog2n）的时间

	- 若文件初始状态接近有序，则选用直接插入排序或冒泡排序为宜，时间均可接近O(n)

		- 时间复杂度与初始状态有关的：直，冒，快

	- 若待排序关键字随机分布，适合快速排序

	- 要求排序稳定且时间复杂度O(nlog2n)，则选用归并排序

	- 若n很大，记录关键字位数较少且可分解时，采用基数排序

	- 当记录信息量较大，为避免消耗大量时间移动记录，可用链表作为存储结构

	- 希尔排序和堆排序利用了顺序存储的随机访问特性，若更换为链式存储，时间复杂度会增加，即时间效率降低

	- 简单选择排序、堆排序、归并排序的时间性能不随记录序列中关键字的分布而改变，即与序列初始状态无关

	- 排序趟数与初始序列无关的排序算法有：直接插入排序，简单选择排序，基数排序，堆排序，归并排序
相关的有：冒泡排序，快速排序
排序趟数！=时间性能，排序趟数无关的比时间性能无关的多

	- 冒泡排序，简单选择排序，堆排序在每趟处理后都能确定一个元素的最终位置；快速排序每趟处理后最少能确定一个元素的最终位置。

	- 1000个无序的元素，用最快的速度挑选出前10个最大的元素，最好的排序方法是堆排序，因为时间复杂度只为10log2n（每一轮调整堆需要log2n,找前10个要10轮调整）

		- 冒泡排序：10n
快速排序：nlog2n(每一次不一定能得到前十个的位置，所以需要全部拍好)
基数排序：k(m+n)
插入排序：n^2(单次不能得到任何一个的确切位置，所以要全部拍好)
归并排序：nlog2n(单次不能得到任何一个的确切位置，所以要全部拍好)

	- 是递归算法的：快速排序，归并排序

### 红色边框为一级知识点：重点

### b站：分享笔记的好人儿

重点考点：
1. 内部排序（时间复杂度、空间复杂度、稳定性、初始状态对排序算法影响、每一趟是否有元素到最终位置、以及各个排序过程和特点）
2. 外排（外排过程、输入输出缓冲区、三种优化的过程（败者树最好会算比较次数、构建k叉哈弗曼树要加入虚段））

## 特别的时间复杂度：

### Prim算法

- O(|V|^2)，V为顶点数

### 哈夫曼算法

- nlog2n

### Kruskal算法

- O(|E|log|E|)，E为边数

